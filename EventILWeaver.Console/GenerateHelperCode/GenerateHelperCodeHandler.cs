using System.Collections.Generic;
using System.IO;
using Scriban;
using Scriban.Runtime;

namespace EventILWeaver.Console.GenerateHelperCode
{
    public class GenerateHelperCodeHandler : HandlerBase
    {
        private readonly string _ilWeavedAutoGeneratedEventAttributeName;

        public GenerateHelperCodeHandler(string ilWeavedAutoGeneratedEventAttributeName)
        {
            _ilWeavedAutoGeneratedEventAttributeName = ilWeavedAutoGeneratedEventAttributeName;
        }

        public int Run(GenerateHelperCodeOptions options)
        {
            var existingTypesWithAutoGeneratedEvents = GetExistingTypesWithAutoGeneratedEvents(options.TargetDllPath, _ilWeavedAutoGeneratedEventAttributeName);

            var template = Template.Parse(HelperCodeTemplate);
            var scriptObject = new ScriptObject
            {
                ["Model"] = new Dictionary<string, object>
                {
                    ["Namespace"] = options.Namespace,
                    ["Usings"] = options.UsingStatements,
                    ["IncludeCustomCodeWhenNoBuildSymbol"] = options.IncludeCustomCodeWhenNoBuildSymbol,
                    ["EnabledBuildSymbol"] = options.EnabledBuildSymbol,
                    ["TypeWithEvents"] = existingTypesWithAutoGeneratedEvents
                }
            };

            var context = new TemplateContext() { MemberRenamer = member => member.Name };
            context.PushGlobal(scriptObject);
            var helperCode = template.Render(context);

            File.WriteAllText(options.OutputFile, helperCode);

            System.Console.WriteLine($"Helper code generated and saved at '{options.OutputFile}'");

            return 0;
        }

        private static readonly string HelperCodeTemplate =
            @"//THIS IS AUTO GENERATED CODE, ANY CHANGES WILL BE OVERWRITTEN
{{ for using in Model.Usings -}}
using {{using}};
{{end}}
namespace {{Model.Namespace}} 
{
#if {{Model.EnabledBuildSymbol}}
	{{ for typeWithEvents in Model.TypeWithEvents -}}
	public static class {{typeWithEvents.Type.Name}}Extensions 
	{
		{{ for event in typeWithEvents.EventsWithAutoGeneratedAttribute }}
		public static void Bind{{event.Name}}(this {{typeWithEvents.Type.Name}} obj, EventHandler<{{event.EventType.GenericArguments[0].Name}}> handler)
	    {
	        obj.{{event.Name}} += handler;
	    }
	
		public static void UnBind{{event.Name}}(this {{typeWithEvents.Type.Name}} obj, EventHandler<{{event.EventType.GenericArguments[0].Name}}> handler)
	    {
	        obj.{{event.Name}} -= handler;
	    }
		{{end}}
	}

	{{end}}
#else
	{{ for typeWithEvents in Model.TypeWithEvents -}}
	public static class {{typeWithEvents.Type.Name}}Extensions 
	{
		{{ for event in typeWithEvents.EventsWithAutoGeneratedAttribute }}
		public static void Bind{{event.Name}}(this {{typeWithEvents.Type.Name}} obj, EventHandler<{{event.EventType.GenericArguments[0].Name}}> handler)
	    {
			{{if Model.IncludeCustomCodeWhenNoBuildSymbol -}}
			{{Model.IncludeCustomCodeWhenNoBuildSymbol}}
			{{else}}
			//No implementation on purpose
			{{-end}}
	    }
	
		public static void UnBind{{event.Name}}(this {{typeWithEvents.Type.Name}} obj, EventHandler<{{event.EventType.GenericArguments[0].Name}}> handler)
	    {
			{{if Model.IncludeCustomCodeWhenNoBuildSymbol -}}
			{{Model.IncludeCustomCodeWhenNoBuildSymbol}}
			{{else}}
			//No implementation on purpose
			{{-end}}
	    }
		{{end}}
	}
	{{-end}}
#endif
}";
    }
}
